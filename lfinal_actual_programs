<html>
<head>
<script>
document.write('<h1 align="right">Squares and Cubes of the numbers from 0 to 10</h1>');
document.write('<center><table width="30%" border="1" bgcolor="white">');
document.write( "<tr> <th>Number</th> <th>Square</th> <th>Cube</th> </tr>" ) ;
for(var n=0; n<=10; n++)
{
document.write( "<tr><td>" + n + "</td><td>" + n*n + "</td><td>" + n*n*n + "</td></tr>" );
}
document.write( "</table>" );
</script>
</head>
</html>student{
    display:block; margin-top:10px; color:Navy;
    } 
USN{
    display:block; margin-left:10px;font-size:14pt; color:Red;
    
} 
name{
    display:block; margin-left:20px;font-size:14pt; color:Blue;
    
} 
college{
    display:block; margin-left:20px;font-size:12pt; color:Maroon;
    
} 
branch{
    display:block; margin-left:20px;font-size:12pt; color:Purple;
    
} 
year{
    display:block; margin-left:20px;font-size:14pt; color:Green;
    
} 
e-mail{
    display:block; margin-left:20px;font-size:12pt; color:Blue;
    
} 
#include <conio.h>
#include <stdio.h>
#include <string.h>

int k = 0, z = 0, i = 0, j = 0, c = 0;
char a[16], ac[20], stk[15], act[10];

void check();
void main()
{
	puts("GRAMMAR is E->E+E \n E->E*E \n E->(E) \n E->id");
	puts("enter input string ");

	gets(a);
	c = strlen(a);
	strcpy(act, "SHIFT->");
	puts("stack \t input \t action");

	for (k = 0, i = 0; j < c; k++, i++, j++) {
		if (a[j] == 'i' && a[j + 1] == 'd') {
			stk[i] = a[j];

			stk[i + 1] = a[j + 1];
			stk[i + 2] = '\0';
			a[j] = ' ';
			a[j + 1] = ' ';
			printf("\n$%s\t%s$\t%sid", stk, a, act);

			check();
		} 
		else

		{
			stk[i] = a[j];
			stk[i + 1] = '\0';

			a[j] = ' ';
			printf("\n$%s\t%s$\t%ssymbols", stk, a, act);
			check();
		}
	}

	getch();
}

void check()
{

	strcpy(ac, "REDUCE TO E");
	for (z = 0; z < c; z++)
		if (stk[z] == 'i' && stk[z + 1] == 'd') {
			stk[z] = 'E';
			stk[z + 1] = '\0';
			printf("\n$%s\t%s$\t%s", stk, a, ac);
			j++;
		}
	for (z = 0; z < c; z++)
		if (stk[z] == 'E' && stk[z + 1] == '+' && stk[z + 2] == 'E') {
			stk[z] = 'E';
			stk[z + 1] = '\0';
			stk[z + 2] = '\0';
			printf("\n$%s\t%s$\t%s", stk, a, ac);
			i = i - 2;
		}
	for (z = 0; z < c; z++)
		if (stk[z] == 'E' && stk[z + 1] == '*' && stk[z + 2] == 'E') {
			stk[z] = 'E';
			stk[z + 1] = '\0';
			stk[z + 1] = '\0';
			printf("\n$%s\t%s$\t%s", stk, a, ac);
			i = i - 2;
		}
	for (z = 0; z < c; z++)
		if (stk[z] == '(' && stk[z + 1] == 'E' && stk[z + 2] == ')') {
			stk[z] = 'E';
			stk[z + 1] = '\0';
			stk[z + 1] = '\0';
			printf("\n$%s\t%s$\t%s", stk, a, ac);
			i = i - 2;
		}
}
from math import exp
from random import seed
from random import random
  
# Initialize a network
def initialize_network(n_inputs, n_hidden, n_outputs):
    network = list()
    hidden_layer = [{'weights':[random() for i in range(n_inputs + 1)]} for i in range(n_hidden)]
    network.append(hidden_layer)
    output_layer = [{'weights':[random() for i in range(n_hidden + 1)]} for i in range(n_outputs)]
    network.append(output_layer)
    return network
  
# Calculate neuron activation for an input
def activate(weights, inputs):
    activation = weights[-1]
    for i in range(len(weights)-1):
        activation += weights[i] * inputs[i]
    return activation
  
# Transfer neuron activation
def transfer(activation):
    return 1.0 / (1.0 + exp(-activation))
  
# Forward propagate input to a network output
def forward_propagate(network, row):
    inputs = row
    for layer in network:
        new_inputs = []
        for neuron in layer:
            activation = activate(neuron['weights'], inputs)
            neuron['output'] = transfer(activation)
            new_inputs.append(neuron['output'])
        inputs = new_inputs
    return inputs
  
# Calculate the derivative of an neuron output
def transfer_derivative(output):
    return output * (1.0 - output)
  
# Backpropagate error and store in neurons
def backward_propagate_error(network, expected):
    for i in reversed(range(len(network))):
        layer = network[i]
        errors = list()
        if i != len(network)-1:
            for j in range(len(layer)):
                error = 0.0
                for neuron in network[i + 1]:
                    error += (neuron['weights'][j] * neuron['delta'])
                errors.append(error)
        else:
            for j in range(len(layer)):
                neuron = layer[j]
                errors.append(expected[j] - neuron['output'])
        for j in range(len(layer)):
            neuron = layer[j]
            neuron['delta'] = errors[j] * transfer_derivative(neuron['output'])
  
# Update network weights with error
def update_weights(network, row, l_rate):
    for i in range(len(network)):
        inputs = row[:-1]
        if i != 0:
            inputs = [neuron['output'] for neuron in network[i - 1]]
        for neuron in network[i]:
            for j in range(len(inputs)):
                neuron['weights'][j] += l_rate * neuron['delta'] * inputs[j]
            neuron['weights'][-1] += l_rate * neuron['delta']
  
# Train a network for a fixed number of epochs
def train_network(network, train, l_rate, n_epoch, n_outputs):
    for epoch in range(n_epoch):
        sum_error = 0
        for row in train:
            outputs = forward_propagate(network, row)
            expected = [0 for i in range(n_outputs)]
            expected[row[-1]] = 1
            sum_error += sum([(expected[i]-outputs[i])**2 for i in range(len(expected))])
            backward_propagate_error(network, expected)
            update_weights(network, row, l_rate)
        print('>epoch=%d, lrate=%.3f, error=%.3f' % (epoch, l_rate, sum_error))
  
# Test training backprop algorithm
seed(1)
 
dataset = [[2.7810836,2.550537003,0],
    [1.465489372,2.362125076,0],
    [3.396561688,4.400293529,0],
    [1.38807019,1.850220317,0],
    [3.06407232,3.005305973,0],
    [7.627531214,2.759262235,1],
    [5.332441248,2.088626775,1],
    [6.922596716,1.77106367,1],
    [8.675418651,-0.242068655,1],
    [7.673756466,3.508563011,1]]
n_inputs = len(dataset[0]) - 1
n_outputs = len(set([row[-1] for row in dataset]))
network = initialize_network(n_inputs, 2, n_outputs)
print(network[0][0])
for layer in network:
    for l in layer:
        print(l)
train_network(network, dataset, 0.5, 20, n_outputs)
for layer in network:
    for l in layer:
        print(l)

    
<?php
header('Content-Type: text/plain');
$allTheStates = "Mississippi Alabama Texas Massachusetts Kansas";
$statesArray = [];
$states1 = explode(' ',$allTheStates);
$i = 0;
//states that ends in xas
foreach($states1 as $state) {
if(preg_match( '/xas$/', ($state)))
{
 $statesArray[$i] = ($state);
$i = $i + 1;
print "\nThe States that ends in xas:" . $state;
}
}
//states that begins with k and ends in s
foreach($states1 as $state)
{
if(preg_match('/^k.*s$/i', ($state)))
{ $statesArray[$i] = ($state);
$i = $i + 1;
echo "\nThe states that begins with k ans ends in s:" . $state;
}
}
//states that begins with M and ends in s
foreach($states1 as $state) {
if(preg_match('/^M.*s$/', ($state)))
{
 $statesArray[$i] = ($state);
$i = $i + 1;
echo "\nThe states that begins with M and ends in s:" . $state;
}
}
//states that ends in a
foreach($states1 as $state) {
if(preg_match('/a$/', ($state)))
{
 $statesArray[$i] = ($state);
$i = $i + 1;
echo "\nThe states that ends in a:" . $state;
}
}
//}
foreach( $statesArray as $element => $value ){
print( "\n" . $value." is the element ". $element);
}
?>
%{
#include "y.tab.h"
	extern yyval;
%}
%%
[0-9]+		{yylval = atoi(yytext); return num;}
[\+\-\*\/]	{return yytext[0];}
[)] 		{return yytext[0];}
[(] 		{return yytext[0];}
. 		{;}
\n		{return 0;}
%%

//Program 1b.l
import csv
import random
import math

def loadCsv(filename):
	lines = csv.reader(open(filename, "r"))
	dataset = list(lines)
	for i in range(len(dataset)):
		dataset[i] = [float(x) for x in dataset[i]]
	return dataset

def splitDataset(dataset, splitRatio):
	trainSize = int(len(dataset) * splitRatio)
	trainSet = []
	copy = list(dataset)
	while len(trainSet) < trainSize:
		index = random.randrange(len(copy))
		trainSet.append(copy.pop(index))
	return [trainSet, copy]

def separateByClass(dataset):
	separated = {}
	for i in range(len(dataset)):
		vector = dataset[i]
		if (vector[-1] not in separated):
			separated[vector[-1]] = []
		separated[vector[-1]].append(vector)

	return separated

def mean(numbers):
	return sum(numbers)/float(len(numbers))

def stdev(numbers):
	avg = mean(numbers)
	variance = sum([pow(x-avg,2) for x in numbers])/float(len(numbers)-1)
	return math.sqrt(variance)

def summarize(dataset):
	summaries = [(mean(attribute), stdev(attribute)) for attribute in zip(*dataset)]
	del summaries[-1]
	return summaries

def summarizeByClass(dataset):
	separated = separateByClass(dataset)
	summaries = {}
	for classValue, instances in separated.items():
		summaries[classValue] = summarize(instances)
	return summaries

def calculateProbability(x, mean, stdev):
	exponent = math.exp(-(math.pow(x-mean,2)/(2*math.pow(stdev,2))))
	return (1 / (math.sqrt(2*math.pi) * stdev)) * exponent

def calculateClassProbabilities(summaries, inputVector):
	probabilities = {}
	for classValue, classSummaries in summaries.items():
		probabilities[classValue] = 1
		for i in range(len(classSummaries)):
			mean, stdev = classSummaries[i]
			x = inputVector[i]
			probabilities[classValue] *= calculateProbability(x, mean, stdev)
	return probabilities
			
def predict(summaries, inputVector):
	probabilities = calculateClassProbabilities(summaries, inputVector)
	bestLabel, bestProb = None, -1
	for classValue, probability in probabilities.items():
		if bestLabel is None or probability > bestProb:
			bestProb = probability
			bestLabel = classValue
	return bestLabel

def getPredictions(summaries, testSet):
	predictions = []
	for i in range(len(testSet)):
		result = predict(summaries, testSet[i])
		predictions.append(result)

	return predictions

def getAccuracy(testSet, predictions):
    correct = 0
    for i in range(len(testSet)):
        #print(testSet[i][-1]," ",predictions[i])
        if testSet[i][-1] == predictions[i]:
            correct += 1

        return (correct/float(len(testSet))) * 100.0

def main():
	filename = '5.csv'
	splitRatio = 0.67
	dataset = loadCsv(filename)
	trainingSet,testSet=splitDataset(dataset, splitRatio) #dividing into training and test data
	#trainingSet = dataset #passing entire dataset as training data
	#testSet=[[8.0,183.0,64.0,0.0,0.0,23.3,0.672,32.0]]
	print('Split {0} rows into train={1} and test={2} rows'.format(len(dataset), len(trainingSet), len(testSet)))
	# prepare model
	summaries = summarizeByClass(trainingSet)
	# test model
	predictions = getPredictions(summaries, testSet)
	accuracy = getAccuracy(testSet, predictions)
	print('Accuracy: {0}%'.format(accuracy))

main()

# Test test
%{
	#include <stdio.h>
	#include <stdlib.h>
	int id=0, dig=0, key=0, op=0;
%}

%token DIGIT ID KEY OP

%%

input:
  DIGIT input {dig++;}
| ID input {id++;}
| KEY input {key++;}
| OP input {op++;}
| DIGIT {dig++;}
| ID {id++;}
| KEY {key++;}
| OP {op++;}
;
%%
#include <stdio.h>

extern int yylex();
extern int yyparse();
extern FILE *yyin;

main() 
{
	FILE *myfile = fopen("sam_input.c", "r");

	if (!myfile) {
		printf("I can't open sam_input.c!");
		return -1;
	}

	yyin = myfile;
	do {
		yyparse();
	}while (!feof(yyin));

	printf("numbers = %d\nKeywords = %d\nIdentifiers = %d\noperators = %d\n", dig, key,id, op);
}
void yyerror() {
	printf("EEK, parse error! Message: ");
	exit(-1);
}
<html>
<head>
<style>
table, td, th
{
border: 1px solid black;
width: 35%;
text-align: center;
background-color: DarkGray;
}
table { margin: auto; }
input,p { text-align:right; }
</style>
</head>
<body>
<form method="post">
<table>
<caption><h2> SIMPLE CALCULATOR </h2></caption>>
<tr><td>First Number:</td><td><input type="text" name="num1" /></td>
<td
 rowspan="2"><input
 type="submit"
 name="submit"
value="calculate"></td></tr>
<tr><td>Second
 Number:</td><td><input
 type="text"
name="num2"/></td></tr>
</form>
<?php
if(isset($_POST['submit'])) // it checks if the input submit is filled
{
$num1 = $_POST['num1'];
$num2 = $_POST['num2'];
if(is_numeric($num1) and is_numeric($num1) )
{
echo "<tr><td> Addition :</td><td><p>".($num1+$num2)."</p></td>";
echo "<tr><td> Subtraction :</td><td><p> ".($num1-$num2)."</p></td>";
echo "<tr><td> Multiplication :</td><td><p>".($num1*$num2)."</p></td>";
echo "<tr><td>Division :</td><td><p> ".($num1/$num2)."</p></td>";
echo "</table>";
}
else
{
echo"<script type='text/javascript' > alert(' ENTER VALID
NUMBER');</script>";
}
}
?>
</body>
</html>
/* Bezier's Curve Flag */
#include <GL/glut.h>
#include <math.h>
#include <stdio.h>

#define PI 3.1416

typedef struct wcPt3D {
	GLfloat x, y, z;
};

int nCr(int n, int r)
{
	if (r == 0)
		return 1;
	else if (r == n)
		return 1;
	else
		return nCr(n - 1, r - 1) + nCr(n - 1, r);
}

void computeBezPt(GLfloat u, wcPt3D* bezPt, GLint nCtrlPts, wcPt3D* ctrlPts)
{
	GLint k, n = nCtrlPts - 1;
	GLfloat bezBlendFcn;
	bezPt->x = bezPt->y = bezPt->z = 0.0;

	for (k = 0; k < nCtrlPts; k++) {
		bezBlendFcn = nCr( n, k ) * pow(u, k) * pow(1 - u, n - k);
		bezPt->x += ctrlPts[k].x * bezBlendFcn;
		bezPt->y += ctrlPts[k].y * bezBlendFcn;
		bezPt->z += ctrlPts[k].z * bezBlendFcn;
	}
}

void bezier(wcPt3D* ctrlPts, GLint nCtrlPts, GLint nBezCurvePts)
{
	wcPt3D bezCurvePt;
	GLfloat u;
	GLint k;
	glBegin(GL_LINE_STRIP);

	for (k = 0; k <= nBezCurvePts; k++) {
		u = GLfloat(k) / GLfloat(nBezCurvePts);
		computeBezPt(u, &bezCurvePt, nCtrlPts, ctrlPts);
		glVertex2f(bezCurvePt.x, bezCurvePt.y);
	}
	glEnd();
}

void displayFcn()
{
	GLint nCtrlPts = 4, nBezCurvePts = 20;

	static float theta = 0;

	wcPt3D ctrlPts[4] = {
		{ 20, 100, 0 },
		{ 30, 110, 0 },
		{ 50, 90, 0 },
		{ 60, 100, 0 }
	};

	ctrlPts[1].x += 10 * sin(theta * PI / 180.0);
	ctrlPts[1].y += 5 * sin(theta * PI / 180.0);
	ctrlPts[2].x -= 10 * sin((theta + 30) * PI / 180.0);
	ctrlPts[2].y -= 10 * sin((theta + 30) * PI / 180.0);
	ctrlPts[3].x -= 4 * sin((theta)*PI / 180.0);
	ctrlPts[3].y += sin((theta - 30) * PI / 180.0);
	theta += 0.9;
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(1.0, 1.0, 1.0);
	glPointSize(5);

	glPushMatrix();
	glLineWidth(5);

	glColor3f(255 / 255, 153 / 255.0, 51 / 255.0);
	for (int i = 0; i < 8; i++) {
		glTranslatef(0, -0.8, 0);
		bezier(ctrlPts, nCtrlPts, nBezCurvePts);
	}

	glColor3f(1, 1, 1);
	for (int i = 0; i < 8; i++) {
		glTranslatef(0, -0.8, 0);
		bezier(ctrlPts, nCtrlPts, nBezCurvePts);
	}

	glColor3f(19 / 255.0, 136 / 255.0, 8 / 255.0);
	for (int i = 0; i < 8; i++) {
		glTranslatef(0, -0.8, 0);
		bezier(ctrlPts, nCtrlPts, nBezCurvePts);
	}

	glPopMatrix();

	glColor3f(0.7, 0.5, 0.3);

	glLineWidth(5);
	glBegin(GL_LINES);
	glVertex2f(20, 100);
	glVertex2f(20, 40);
	glEnd();

	glFlush();
	glutPostRedisplay();
	glutSwapBuffers();
}

void winReshapeFun(GLint newWidth, GLint newHeight)
{
	glViewport(0, 0, newWidth, newHeight);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0, 130, 0, 130);
	glClear(GL_COLOR_BUFFER_BIT);
}

int main(int argc, char** argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
	glutInitWindowPosition(50, 50);
	glutInitWindowSize(600, 600);
	glutCreateWindow("Bezier Curve");
	glutDisplayFunc(displayFcn);
	glutReshapeFunc(winReshapeFun);
	glutMainLoop();
	return 0;
}
/* Spin colored cube using transformation matrices */
#include <GL/glut.h>
#include <stdlib.h>

GLfloat vertices[][3] = { { -1.0, -1.0, -1.0 }, { 1.0, -1.0, -1.0 },
	{ 1.0, 1.0, -1.0 }, { -1.0, 1.0, -1.0 }, { -1.0, -1.0, 1.0 },
	{ 1.0, -1.0, 1.0 }, { 1.0, 1.0, 1.0 }, { -1.0, 1.0, 1.0 } };

GLfloat normals[][3] = { { -1.0, -1.0, -1.0 }, { 1.0, -1.0, -1.0 },
	{ 1.0, 1.0, -1.0 }, { -1.0, 1.0, -1.0 }, { -1.0, -1.0, 1.0 },
	{ 1.0, -1.0, 1.0 }, { 1.0, 1.0, 1.0 }, { -1.0, 1.0, 1.0 } };

GLfloat colors[][3] = { { 0.0, 0.0, 0.0 }, { 1.0, 0.0, 0.0 },
	{ 1.0, 1.0, 0.0 }, { 0.0, 1.0, 0.0 }, { 0.0, 0.0, 1.0 },
	{ 1.0, 0.0, 1.0 }, { 1.0, 1.0, 1.0 }, { 0.0, 1.0, 1.0 } };

void polygon(int a, int b, int c, int d)
{
	glBegin(GL_POLYGON);
	glColor3fv(colors[a]);
	glNormal3fv(normals[a]);
	glVertex3fv(vertices[a]);
	glColor3fv(colors[b]);
	glNormal3fv(normals[b]);
	glVertex3fv(vertices[b]);
	glColor3fv(colors[c]);
	glNormal3fv(normals[c]);
	glVertex3fv(vertices[c]);
	glColor3fv(colors[d]);
	glNormal3fv(normals[d]);
	glVertex3fv(vertices[d]);
	glEnd();
}

void colorcube(void)
{
	polygon(0, 3, 2, 1);
	polygon(2, 3, 7, 6);
	polygon(0, 4, 7, 3);
	polygon(1, 2, 6, 5);
	polygon(4, 5, 6, 7);
	polygon(0, 1, 5, 4);
}

static GLfloat theta[] = { 0.0, 0.0, 0.0 };
static GLint axis = 2;

void display(void)
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glLoadIdentity();
	glRotatef(theta[0], 1.0, 0.0, 0.0);
	glRotatef(theta[1], 0.0, 1.0, 0.0);
	glRotatef(theta[2], 0.0, 0.0, 1.0);

	colorcube();

	glFlush();
	glutSwapBuffers();
}

void spinCube()
{
	theta[axis] += 1.0;
	if (theta[axis] > 360.0)
		theta[axis] -= 360.0;
	glutPostRedisplay();
}

void mouse(int btn, int state, int x, int y)
{
	if (btn == GLUT_LEFT_BUTTON && state == GLUT_DOWN)
		axis = 0;
	if (btn == GLUT_MIDDLE_BUTTON && state == GLUT_DOWN)
		axis = 1;
	if (btn == GLUT_RIGHT_BUTTON && state == GLUT_DOWN)
		axis = 2;
}

void myReshape(int w, int h)
{
	glViewport(0, 0, w, h);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (w <= h)
		glOrtho(-2.0, 2.0, -2.0 * (GLfloat)h / (GLfloat)w, 2.0 * (GLfloat)h / (GLfloat)w, -10.0, 10.0);
	else
		glOrtho(-2.0 * (GLfloat)w / (GLfloat)h, 2.0 * (GLfloat)w / (GLfloat)h, -2.0, 2.0, -10.0, 10.0);
	glMatrixMode(GL_MODELVIEW);
}

int main(int argc, char** argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
	glutInitWindowSize(500, 500);
	glutCreateWindow("Rotating a Color Cube");
	glutReshapeFunc(myReshape);
	glutDisplayFunc(display);
	glutIdleFunc(spinCube);
	glutMouseFunc(mouse);
	glEnable(GL_DEPTH_TEST);
	glutMainLoop();
	return 0;
}
/* Program: Clip a lines using Cohen-Sutherland algorithm */

#include <GL/glut.h>
#include <stdio.h>
#define outcode int

double xmin = 50, ymin = 50, xmax = 100, ymax = 100;
double xvmin = 200, yvmin = 200, xvmax = 300, yvmax = 300;

float X0, Y0, X1, Y1;
const int RIGHT = 2;
const int LEFT = 1;
const int TOP = 8;
const int BOTTOM = 4;

outcode ComputeOutCode(double x, double y);

void CohenSutherlandLineClipAndDraw(double x0, double y0, double x1, double y1)
{
	outcode outcode0, outcode1, outcodeOut;
	bool accept = false, done = false;
	outcode0 = ComputeOutCode(x0, y0);
	outcode1 = ComputeOutCode(x1, y1);

	do {
		if (!(outcode0 | outcode1)) {
			accept = true;
			done = true;
		} else if (outcode0 & outcode1)
			done = true;
		else {
			double x, y, m;
			m = (y1 - y0) / (x1 - x0);
			outcodeOut = outcode0 ? outcode0 : outcode1;
			if (outcodeOut & TOP) {
				x = x0 + (ymax - y0) / m;
				y = ymax;
			} else if (outcodeOut & BOTTOM) {
				x = x0 + (ymin - y0) / m;
				y = ymin;
			} else if (outcodeOut & RIGHT) {
				y = y0 + (xmax - x0) * m;
				x = xmax;
			} else {
				y = y0 + (xmin - x0) * m;
				x = xmin;
			}
			if (outcodeOut == outcode0) {
				x0 = x;
				y0 = y;
				outcode0 = ComputeOutCode(x0, y0);
			} else {
				x1 = x;
				y1 = y;
				outcode1 = ComputeOutCode(x1, y1);
			}
		}
	} while (!done);
	glColor3f(1.0, 0.0, 0.0);
	glBegin(GL_LINE_LOOP);
	glVertex2f(xvmin, yvmin);
	glVertex2f(xvmax, yvmin);
	glVertex2f(xvmax, yvmax);
	glVertex2f(xvmin, yvmax);
	glEnd();
	printf("\n%f   %f :  %f   %f", x0, y0, x1, y1);

	if (accept) {
		double sx = (xvmax - xvmin) / (xmax - xmin);
		double sy = (yvmax - yvmin) / (ymax - ymin);
		double vx0 = xvmin + (x0 - xmin) * sx;
		double vy0 = yvmin + (y0 - ymin) * sy;
		double vx1 = xvmin + (x1 - xmin) * sx;
		double vy1 = yvmin + (y1 - ymin) * sy;

		glColor3f(0.0, 0.0, 1.0);
		glBegin(GL_LINES);
		glVertex2d(vx0, vy0);
		glVertex2d(vx1, vy1);
		glEnd();
	}
}

outcode ComputeOutCode(double x, double y)
{
	outcode code = 0;
	if (y > ymax)
		code |= TOP;
	else if (y < ymin)
		code |= BOTTOM;
	if (x > xmax)
		code |= RIGHT;
	else if (x < xmin)
		code |= LEFT;
	return code;
}
void display()
{
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(1.0, 0.0, 0.0);
	glBegin(GL_LINES);
	glVertex2d(X0, Y0);
	glVertex2d(X1, Y1);
	glEnd();
	glColor3f(0.0, 0.0, 1.0);
	glBegin(GL_LINE_LOOP);
	glVertex2f(xmin, ymin);
	glVertex2f(xmax, ymin);
	glVertex2f(xmax, ymax);
	glVertex2f(xmin, ymax);
	glEnd();
	CohenSutherlandLineClipAndDraw(X0, Y0, X1, Y1);
	glFlush();
}

void myinit()
{
	glClearColor(1.0, 1.0, 1.0, 1.0);
	glColor3f(1.0, 0.0, 0.0);
	glPointSize(1.0);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0.0, 499.0, 0.0, 499.0);
}

void main(int argc, char** argv)
{
	printf("Enter end points : ");
	scanf("%f%f%f%f", &X0, &Y0, &X1, &Y1);
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowSize(500, 500);
	glutInitWindowPosition(0, 0);
	glutCreateWindow("Cohen Sutherland Line Clipping    
			Algorithm");
	glutDisplayFunc(display);
	myinit();
	glutMainLoop();
}
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

char STACK[20] = "\0";
int TOP = -1, flag = 0;
int B_ptr = 0;
char BUFFER[20], G_prod[20];

char table[3][3][10] = { "NT", "a", "b",
			"A", "aBa", "Error",
			"B", "Îµ", "bB" };

char pop()
{
	char ch;
	ch = STACK[TOP--];
	return ch;
}

void stack_content()
{
	if (TOP != -1) 
	{
		int i = 0;
		printf("\nstack content: ");
		while (i <= TOP) {
			printf("%c", STACK[i++]);
		}
		printf("\n");
	}
}

int isterm(char c)
{
	if (c >= 'a' && c <= 'z')
		return 1;
	else
		return 0;
}

int Parser_table(char stack_top, char buf_value, int flag)
{

	int r, c;
	switch (stack_top) 
	{
		case 'A':
			r = 1;
			break;

		case 'B':
			if (flag <= 5)
				r = 2;
			else
				r = 3;
	}

	switch (buf_value) 
	{
		case 'a':
			c = 1;
			break;

		case 'b':
			c = 2;
	}

	if (strcmp(table[r][c], "error") == 0)
		return 0;

	if (strcmp(table[r][c], "Îµ") != 0) 
	{
		strcpy(G_prod, table[r][c]);
	}
	return 1;
}

int main()
{
	int i, j, stln;
	printf("LL(1)  PARSER  TABLE \n");
	for (i = 0; i < 3; i++) 
	{
		for (j = 0; j < 3; j++) 
		{
			printf("%s\t", table[i][j]);
		}
		printf("\n");
	}
	printf("\n");
	printf("ENTER THE STRING into the Buffer and also give a ';' as the terminator: ");
	scanf("%s", BUFFER);
	printf("\n THE STRING in the Buffer is %s", BUFFER);
	if (BUFFER[strlen(BUFFER) - 1] != ';') 
	{
		printf("END OF STRING MARKER SHOULD BE ';'");
		exit(0);
	}
	push('$');
	push('A');
	while (STACK[TOP] != '$') // Stack is not Empty
	{
		flag++;
		if (STACK[TOP] == BUFFER[B_ptr]) // X is a
		{
			printf("\n1.The popped item is - %c,", pop());
			B_ptr++;
			printf("\t buffer cont - %.*s", strlen(BUFFER), BUFFER + B_ptr);
		} 
		else if (isterm(STACK[TOP])) // is X is terminal
		{
			printf("\n2. $ %c", STACK[TOP]);
			printf("\t Error in Parsing \n");
		} 
		else if (!Parser_table(STACK[TOP], BUFFER[B_ptr], flag))
			printf("3. Error Entry in Parse Table ");
		else if (Parser_table(STACK[TOP], BUFFER[B_ptr], flag)) 
		{
			if (flag < 6 && strcmp(G_prod, "Îµ") != 0)
			{
				printf("\n4.1 flag = %d, prod id- %s*\t", flag, G_prod);
				pop();
				stln = strlen(G_prod);
				for (i = stln - 1; i >= 0; i--)
					push(G_prod[i]);
				stack_content();
			} 
			else 
			{
				stack_content();
				printf("\n4.2 flag = %d  *reduce by %s*", flag, "B->Îµ");
				pop();
				printf("\t buffer content is %c", BUFFER[B_ptr]);
			}
		}
	}
	if (STACK[TOP] == '$' && BUFFER[B_ptr] == ';')
		printf("\n** The string is accepted **");
	else
		printf("\n** The string is not accepted **");
}
<html>
<body>
<script type="text/javascript">
var num,rev=0,remainder;
var n = prompt("Enter the number","");
if(isNaN(n))
{
alert("ENTER VALID NUMBER");
}
else
{
num=n;
while(num!=0)
{
remainder = num%10;
num = parseInt(num/10);
rev = rev * 10 + remainder;
}
alert("Reverse of " +n+ " is "+rev);
}
</script>
</body>
</html>
%{
#include<stdio.h>
	int v=0,op=0,id=0,flag=0;
	%}

%%

[a-z A-Z]+[0-9 A-Z a-z]*  {id++;printf("\n Identifier:");ECHO;}
[\+\-\*\/\=]    {op++;printf("\n Operator:");ECHO;}
"("    {v++;}
")"    {v--;}
";"    {flag=1;}
.|\n   {;}

%%

int main()
{
	printf("enter the expression");
	yylex();

	if(((op+1)==id)&&(v==0)&&(flag==0))
	{
		printf("\n valid expression\n");
		printf("no of identifiers %d\n",id);
		printf("no of operators %d\n",op);
	}
	else
		printf("\n Invalid expression\n");
}

int yywrap()
{
	return 1;
}


//Program1a.l
#include <stdio.h>
#include <stdlib.h>

int main()
{

	int Max[10][10], need[10][10], alloc[10][10], avail[10],completed[10], safeSequence[10];

	int p, r, i, j, process, count;
	count = 0;

	printf("Enter the no of processes : ");
	scanf("%d", &p);

	for (i = 0; i < p; i++)
		completed[i] = 0;

	printf("\n\nEnter the no of resources : ");
	scanf("%d", &r);

	printf("\n\nEnter the Max Matrix for each process : ");

	for (i = 0; i < p; i++)
	{
		printf("\nFor process %d : ", i + 1);
		for (j = 0; j < r; j++)
			scanf("%d", &Max[i][j]);
	}

	printf("\n\nEnter the allocation for each process : ");
	for (i = 0; i < p; i++)
	{
		printf("\nFor process %d : ", i + 1);
		for (j = 0; j < r; j++)
			scanf("%d", &alloc[i][j]);
	}

	printf("\n\nEnter the Available Resources : ");
	for (i = 0; i < r; i++)
		scanf("%d", &avail[i]);

	for (i = 0; i < p; i++)
		for (j = 0; j < r; j++)
			need[i][j] = Max[i][j] - alloc[i][j];

	do {
		printf("\n Max matrix:\tAllocation matrix:\n");
		for (i = 0; i < p; i++) {
			for (j = 0; j < r; j++)
				printf("%d ", Max[i][j]);
			printf("\t\t");
			for (j = 0; j < r; j++)
				printf("%d ", alloc[i][j]);
			printf("\n");
		}

		process = -1;
		for (i = 0; i < p; i++)
		{
			if (completed[i] == 0) //if not completed
			{
				process = i;
				for (j = 0; j < r; j++)
				{
					if (avail[j] < need[i][j]) {
						process = -1;
						break;
					}
				}
			}

			if (process != -1)
				break;
		}
		if (process != -1)
		{
			printf("\nProcess %d runs to completion!", process + 1);
			safeSequence[count] = process + 1;
			count++;
			for (j = 0; j < r; j++) {
				avail[j] += alloc[process][j];
				alloc[process][j] = 0;
				Max[process][j] = 0;
				completed[process] = 1;
			}
		}
	} while (count != p && process != -1);

	if (count == p) {
		printf("\nThe system is in a safe state!!\n");
		printf("Safe Sequence : < ");
		for (i = 0; i < p; i++)
			printf("%d ", safeSequence[i]);
		printf(">\n");
	}

	else
		printf("\nThe system is in an unsafe state!!");
}
%{
#include<stdio.h>
#include<stdlib.h>
%}
%token num
%left '+' '-'
%left '*' '/'
%%

input:exp 	{printf("%d\n",$$);exit(0);}
exp:exp'+'exp 	{$$=$1+$3;}
|exp'-'exp 	{$$=$1-$3;}
|exp'*'exp 	{$$=$1*$3;}
|exp'/'exp 	{ 
			if($3==0){
				printf("Divide by Zero\n");exit(0);
			} 
			else $$=$1/$3;
		}
|'('exp')' 	{$$=$2;}
|num 		{$$=$1;};

%%

int yyerror()
{
	printf("error");
	exit(0);
}

 
int main() 
{ 
	printf("Enter an expression:\n"); 
	yyparse();
}

//Progrm1b.y
/* Simple shaded scene with a teapot */
#include <GL/glut.h>

void obj(double tx, double ty, double tz, double sx, double sy,
		double sz)
{
	glRotated(50, 0, 1, 0);
	glRotated(10, -1, 0, 0);
	glRotated(11.7, 0, 0, -1);
	glTranslated(tx, ty, tz);
	glScaled(sx, sy, sz);
	glutSolidCube(1.0);
	glLoadIdentity();
}

void display()
{
	glViewport(0, 500, 500, 500);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	obj(0, 0, 0.5, 1, 1, 0.04);
	obj(-0.5, 0, 0, 0.04, 1, 1);
	obj(0, -3.0, 0, 0.02, 0.2, 0.02);
	obj(0, -0.3, -0.4, 0.02, 0.2, 0.02);
	obj(0.4, -0.3, 0, 0.02, 0.2, 0.02);
	obj(0.4, -0.3, -0.4, 0.02, 0.2, 0.02);
	obj(0.2, -0.18, -0.2, 0.8, 0.02, 0.8);
	obj(0, -0.5, 0.02, 1, 0.02, 1);
	glTranslated(0.03, -0.2, -0.5);
	glutSolidTeapot(0.1);
	glLoadIdentity();
	glFlush();
}

void main(int argc, char** argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);
	GLfloat ambient[] = { 0.3, 0.4, 0.5, 1 };
	GLfloat Light_pos[] = { 27, 80, 2, 3 };
	glutInitWindowSize(1000, 1000);
	glutInitWindowPosition(10, 10);
	glutCreateWindow("Teapot and Table");
	glutDisplayFunc(display);
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
	glMaterialfv(GL_FRONT, GL_AMBIENT, ambient);
	glLightfv(GL_LIGHT0, GL_POSITION, Light_pos);
	glEnable(GL_DEPTH_TEST);
	glutMainLoop();
}
<?php
$a = array(array(1,2,3),array(4,5,6),array(7,8,9));
$b = array(array(7,8,9),array(4,5,6),array(1,2,3));
echo "the first matrix
 :"."<br/>";
for ($row = 0; $row < 3; $row++) {
for ($col = 0; $col < 3; $col++)
echo " ".$a[$row][$col];
echo "<br/>";
}
echo "the second matrix
 :"."<br/>";
for ($row = 0; $row < 3; $row++) {
for ($col = 0; $col < 3; $col++)
echo " ".$b[$row][$col];
echo "<br/>";
}
echo "the transpose for the first matrix is:"."<br/>";
for ($row = 0; $row < 3; $row++) {
for ($col = 0; $col <3; $col++)
echo " ".$a[$col][$row];
echo "<br/>";
}
echo "the addition of matrices is:"."<br/>";
for ($row = 0; $row < 3; $row++) {
for ($col = 0; $col < 3; $col++)
echo " ".$a[$row][$col]+$b[$row][$col]." ";
echo "<br/>";
}
$m=count($a);
$n=count($a[2]);
$p=count($b);
$q=count($b[2]);
if($n!= $p){
echo "Incompatible matrices";
exit(0);
}

echo " The multiplication of matrices: <br/>";
$result=array();
for ($i=0; $i< $m; $i++) {
for($j=0; $j < $q; $j++) {
$result[$i][$j] = 0;
for($k=0; $k < $n; $k++)
$result[$i][$j] += $a[$i][$k] * $b[$k][$j];
}
}
for ($row = 0; $row < 3; $row++) {
for ($col = 0; $col < 3; $col++)
echo " ".$result[$row][$col];
echo "<br/>";
}
?>
<html>
<body>
<script type="text/javascript">
var str = prompt("Enter the string","");
str = str.toUpperCase();
for(var i = 0; i<str.length; i++)
{
var chr = str.charAt(i);
if(chr == 'A' || chr == 'E' || chr == 'I' || chr == 'O' || chr == 'U')
break;
}
if( i<str.length )
alert("The position of the left most vowel is "+(i+1));
else
alert("No vowel found in the entered string");
</script>
</body>
</html>
%{
#include <stdio.h>
#include "y.tab.h"

extern yylval;

%}
%%
[ \t] ;
[+|-|*|/|=|<|>] {
			printf("operator is %s\n",yytext);
			return OP;
		}
[0-9]+ 		{
			yylval = atoi(yytext);
			printf("numbers is %d\n",yylval);
			return DIGIT;
		}
int|char|bool|float|void|for|do|while|if|else|return|void {
			printf("keyword is %s\n",yytext);
			return KEY;
		}
[a-zA-Z0-9]+ 	{
			printf("identifier is %s\n",yytext);
			return ID;
		}
. ;
%%

<!DOCTYPE html>
<html>
<body>
<p id="myP1">TEXT-GROWING.</p>
<p id="myP2">TEXT-SHRININKING</p>
</body>
<script>
//Global declerations
var size = 10;
vari =0;
var myWait1 = setInterval(GrowText1, 100);
function GrowText1()
{
if(size<51)
{
size = size + 1;
document.getElementById("myP1").style.fontSize = (size+'pt');
document.getElementById("myP1").style.color = "red";
//Hide the paragraph "text-shriniking"
document.getElementById("myP2").style.visibility = "hidden";
}
else
{
clearInterval(myWait1);
myWait1 = setInterval(ShrinkText1, 100);
//Now hide the 1st paragraph and display the second paragraph
document.getElementById("myP1").style.visibility = "hidden";
document.getElementById("myP1").style.fontSize = '1pt';
document.getElementById("myP2").style.visibility = "visible";
}
}
function ShrinkText1()
{
if(size>5)
{
size = size - 1;
document.getElementById("myP2").style.fontSize = (size+'pt');
document.getElementById("myP2").style.color = "blue";
}
else
{
clearInterval(myWait1);
}
}
</script>
</html>
/* Scan-Line algorithm for filling a polygon */
#define BLACK 0
#include <GL/glut.h>
#include <stdio.h>
#include <stdlib.h>
float x1, x2, x3, x4, y1, y2, y3, y4;
void edgedetect(float x1, float y1, float x2, float y2, int* le, int* re)
{
	float mx, x, temp;
	int i;
	if ((y2 - y1) < 0) {
		temp = y1;
		y1 = y2;
		y2 = temp;
		temp = x1;
		x1 = x2;
		x2 = temp;
	}
	if ((y2 - y1) != 0)
		mx = (x2 - x1) / (y2 - y1);
	else
		mx = x2 - x1;
	x = x1;
	for (i = y1; i <= y2; i++) {
		if (x < (float)le[i])
			le[i] = (int)x;
		if (x > (float)re[i])
			re[i] = (int)x;
		x += mx;
	}
}

void draw_pixel(int x, int y, int value)
{
	glColor3f(1.0, 1.0, 0.0);
	glBegin(GL_POINTS);
	glVertex2i(x, y);
	glEnd();
}

void scanfill(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
{
	int le[500], re[500];
	int i, y;
	for (i = 0; i < 500; i++) {
		le[i] = 500;
		re[i] = 0;
	}
	edgedetect(x1, y1, x2, y2, le, re);
	edgedetect(x2, y2, x3, y3, le, re);
	edgedetect(x3, y3, x4, y4, le, re);
	edgedetect(x4, y4, x1, y1, le, re);
	for (y = 0; y < 500; y++) {
		if (le[y] <= re[y])

			for (i = (int)le[y]; i < (int)re[y]; i++)

				draw_pixel(i, y, BLACK);
	}
}

void display()
{
	x1 = 200.0;
	y1 = 200.0;
	x2 = 100.0;
	y2 = 300.0;
	x3 = 200.0;
	y3 = 400.0;
	x4 = 300.0;
	y4 = 300.0;
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(0.0, 0.0, 1.0);
	glBegin(GL_LINE_LOOP);
	glVertex2f(x1, y1);
	glVertex2f(x2, y2);
	glVertex2f(x3, y3);
	glVertex2f(x4, y4);
	glEnd();
	scanfill(x1, y1, x2, y2, x3, y3, x4, y4);
	glFlush();
}

void myinit()
{
	glClearColor(1.0, 1.0, 1.0, 1.0);
	glColor3f(1.0, 0.0, 0.0);
	glPointSize(1.0);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0.0, 499.0, 0.0, 499.0);
}

void main(int argc, char** argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowSize(500, 500);
	glutInitWindowPosition(0, 0);
	glutCreateWindow("Filling a Polygon usingScan-line Algorithm");
	glutDisplayFunc(display);
	myinit();
	glutMainLoop();
}
%{
	#include<stdio.h>
	int c_count=0;
%}

%%
"/*"[^*/]*"*/" 	{c_count++;}		/*for single and multiple line comments*/
"//".* 		{c_count++;}		/*for single line comments*/
%%

int main( int argc, char **argv)
{
	FILE *f1,*f2;
	if(argc>1)			/*Pass two filenames for execution*/
	{

		f1=fopen(argv[1],"r");	/*open first file for reading*/
		if(!f1)			/*not able to open file*/
		{
			printf("file error \n");
			exit(1);
		}
		yyin=f1;
		f2=fopen(argv[2],"w");	/*open second file for writing*/
		if(!f2)			/*not able to open file*/
		{
			printf("Error");
			exit(1);
		}
		yyout=f2;
		yylex();
		printf("Number of Comment Lines: %d\n",c_count);
	}

	return 0;
}

/* 3-D Sierpinski Gasket */
#include <GL/glut.h>
#include <stdio.h>
#include <stdlib.h>
typedef float point[3];
point v[] = { { 0.0, 0.0, 1.0 }, { 0.0, 1.0, 0.0 },
    { -1.0, -0.5, 0.0 }, { 1.0, -0.5, 0.0 } };
int n;

void triangle(point a, point b, point c)
{
    glBegin(GL_POLYGON);
    glVertex3fv(a);
    glVertex3fv(b);
    glVertex3fv(c);
    glEnd();
}

void divide_triangle(point a, point b, point c, int m)
{
    point v1, v2, v3;
    int j;
    if (m > 0) {
	    for (j = 0; j < 3; j++) {
		    v1[j] = (a[j] + b[j]) / 2;
		    v2[j] = (a[j] + c[j]) / 2;
		    v3[j] = (c[j] + b[j]) / 2;
	    }
	    divide_triangle(a, v1, v2, m - 1);
	    divide_triangle(c, v2, v3, m - 1);
	    divide_triangle(b, v3, v1, m - 1);
    } else
	    (triangle(a, b, c));
}

void tetrahedron(int m)
{
	glColor3f(1.0, 0.0, 0.0);
	divide_triangle(v[0], v[1], v[2], m);
	glColor3f(0.0, 1.0, 0.0);
	divide_triangle(v[3], v[2], v[1], m);
	glColor3f(0.0, 0.0, 1.0);
	divide_triangle(v[0], v[3], v[1], m);
	glColor3f(0.0, 0.0, 0.0);
	divide_triangle(v[0], v[2], v[3], m);
}

void display(void)
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glLoadIdentity();
	tetrahedron(n);
	glFlush();
}

void myReshape(int w, int h)
{
	glViewport(0, 0, w, h);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (w <= h)
		glOrtho(-2.0, 2.0, -2.0 * (GLfloat)h / (GLfloat)w, 2.0 * (GLfloat)h / (GLfloat)w, -10.0, 10.0);
	else
		glOrtho(-2.0 * (GLfloat)w / (GLfloat)h, 2.0 * (GLfloat)w / (GLfloat)h, -2.0, 2.0, -10.0, 10.0);
	glMatrixMode(GL_MODELVIEW);
	glutPostRedisplay();
}
void main(int argc, char** argv)
{
	printf("No of Recursive steps/Division: ");
	scanf("%d", &n);
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);
	glutCreateWindow(" 3D Sierpinski gasket");
	glutReshapeFunc(myReshape);
	glutDisplayFunc(display);
	glEnable(GL_DEPTH_TEST);
	glClearColor(1.0, 1.0, 1.0, 0.0);
	glutMainLoop();
}
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char tset[4][3][3] = { 
	{ "-", "B", "?" },
	{ "+", "C", "D" },
	{ "*", "0", "1" },
	{ "=", "A", "2" }
};

int main()
{
	int row, col;
	for (row = 0; row < 4; row++) {
		col = 2;
		if (tset[row][col][0] == '?') {
			printf("\nLD R0,%s%s", tset[row][0], tset[row][1]);
		} 
		else {
			if (tset[row][0][0] == '+') {
				printf("\nLD R1,%s", tset[row][1]);
				printf("\nLD R2,%s", tset[row][2]);
				printf("\nADD R1,R1,R2");
			} 
			else {
				if (tset[row][0][0] == '*') {
					printf("\nMUL R1,R1,R0");
				} 
				else {
					printf("\nST %s,R1", tset[row][1]);
				}
			}
		}
	}
	printf("\n");
	return 0;
}
#include<stdio.h>
#include<stdlib.h>

void FIFO()
{
	char s[200];
	char F[200];
	int l,f,i,j=0,k,flag=0,cnt=0;

	printf("\nEnter the number of frames : ");
	scanf("%d",&f);

	printf("\nEnter the length of the string: ");
	scanf("%d",&l);

	printf("\nEnter the string: ");
	scanf("%s", s);

	for(i=0;i<f;i++)
		F[i]=' ';

	printf("\n\tPAGE\t\tFRAMES\t\t\tFAULTS");
	for(i=0;i<l;i++)
	{
		for(k=0;k<f;k++)
			if(F[k]==s[i])
				flag=1;

		if(flag==0)
		{
			printf("\n\t%c\t",s[i]);
			F[j]=s[i];
			j++;
			for(k=0;k<f;k++)
				printf("\t%c",F[k]);
			printf("\tPage-fault%d",cnt);
			cnt++;
		}
		else
		{
			flag=0;
			printf("\n\t%c\t",s[i]);
			for(k=0;k<f;k++)
				printf("\t%c",F[k]);
			printf("\tNo page-fault");
		}
		if(j==f)
			j=0;
	}
}

int findLRU(int time[], int n)
{
	int i, minimum = time[0], pos = 0;
	for(i = 1; i < n; ++i)
	{
		if(time[i] < minimum)
		{
			minimum = time[i];
			pos = i;
		}
	}
	return pos;
}

int lru()
{
	int no_of_frames, no_of_pages, frames[10], counter = 0;
	int time[10], flag1, flag2, i, j, pos, faults = 0, page;
	char s[200];

	printf("\nEnter number of frames: ");
	scanf("%d", &no_of_frames);

	printf("\nEnter number of pages: ");
	scanf("%d", &no_of_pages);

	printf("\nEnter reference string: ");
	scanf("%s", s);

	for(i = 0; i < no_of_frames; ++i)
		frames[i] = -1;

	for(i = 0; i < no_of_pages; ++i)
	{
		flag1 = flag2 = 0;
		page = s[i] - '0';
		for(j = 0; j < no_of_frames; ++j) 
		{
			if(frames[j] == page)
			{
				counter++;
				time[j] = counter;
				flag1 = flag2 = 1;
				break;
			}
		}
		if(flag1 == 0)
		{
			for(j = 0; j < no_of_frames; ++j)
			{
				if(frames[j] == -1)
				{
					counter++;
					faults++;
					frames[j] = page;
					time[j] = counter;
					flag2 = 1;
					break;
				}
			}    
		}
		if(flag2 == 0)
		{
			pos = findLRU(time, no_of_frames);
			counter++;
			faults++;
			frames[pos] = page;
			time[pos] = counter;
		}
		printf("\n");
		for(j = 0; j < no_of_frames; ++j)
			printf("%d\t", frames[j]);
	}
	printf("\n\nTotal Page Faults = %d", faults);
	return 0;
}

int main()
{
	int ch,YN=1,i,l,f;
	char F[10],s[25];
	do
	{
		printf("\nOptions : ");
		printf("\n\n1:FIFO\n2:LRU \n3:EXIT");
		printf("\n\nEnter your choice: ");
		scanf("%d",&ch);
		switch(ch)
		{
			case 1:	FIFO();
				break;
			case 2: lru();
				break;
			default: 
				exit(0);
		}
		printf("\n\nPress 1 to continue.. 0 to exit "); 
		scanf("%d",&YN);
	}while(YN==1);
	return(0);
}


<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type="text/css" href="5.css" ?> 
<html> 
<head> 
<h1>  STUDENTS DESCRIPTION </h1> </head> 
<students> 
<student> 
<USN>USN        :   1KS15CS001</USN> 
<name>NAME      :   ABC</name>
<college>COLLEGE:   KSIT</college> 
<branch>BRANCH  :   Computer Science and Engineering</branch> 
<year>YEAR      :   2015</year> 
<e-mail>E-Mail  :   ABC@gmail.com</e-mail> 
</student> <student>  
<USN>USN        :   1KS15ME001</USN> 
<name>NAME      :   XYZ</name>
<college>COLLEGE:   KSIT</college> 
<branch>BRANCH  :   Mechanical Engineering</branch>
<year>YEAR      :   2015</year> 
<e-mail>E-Mail  :   XYZ@gmail.com</e-mail> 
</student>
 <student>  
<USN>USN        :   1KS15EC001</USN> 
<name>NAME      :   WTA</name> 
<college>COLLEGE:   KSIT</college>
<branch>BRANCH   : Electronics and Communication Engineering </branch> 
<year>YEAR       :   2015</year> 
<e-mail>E-Mail   :   WTA@gmail.com</e-mail> 
</student> 
</students>
</html> /* Triangle rotation */
#include <GL/glut.h>
#include <math.h>
#include <stdio.h>

GLfloat tri[3][3] = { { 100, 100, 0 }, { 200, 100, 0 }, { 150, 200, 0 } };
GLfloat arb_x = 100;
GLfloat arb_y = 100;
GLfloat rot_angle;

void drawtri()
{

	glBegin(GL_LINE_LOOP);
	glVertex3fv(tri[0]);
	glVertex3fv(tri[1]);
	glVertex3fv(tri[2]);
	glEnd();
}
void display()
{
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(1, 0, 0);
	drawtri();
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glTranslatef(arb_x, arb_y, 0.0);
	glRotatef(rot_angle, 0.0, 0.0, 1.0);
	glTranslatef(-arb_x, -arb_y, 0.0);
	glColor3f(0, 1, 0);
	drawtri();
	glTranslatef(0.0, 0.0, 0.0);
	glRotatef(rot_angle, 0.0, 0.0, 1.0);
	glTranslatef(-0.0, -0.0, 0.0);
	glColor3f(0, 0, 1);
	drawtri();

	glFlush();
}
void myinit()
{
	glClearColor(0.0, 0.0, 0.0, 0.0);
	glColor3f(1.0, 0.0, 0.0);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(-250.0, 499.0, -250.0, 499.0);
}

void main(int argc, char* argv[])
{
	printf("\nENTER THE ROTATION ANGLE :-\n");
	scanf("%f", &rot_angle);
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowSize(500, 500);
	glutInitWindowPosition(0, 0);
	glutCreateWindow("House Rotation");
	glutDisplayFunc(display);
	myinit();
	glutMainLoop();
}
%{
#include<stdio.h>
#include<stdlib.h>
%}
%token A B

%%

input:s'\n' {printf("Successful Grammar\n");exit(0);}
s: A s1 B| B
s1: ; | A s1

%%

main()
{
	printf("Enter A String\n");
	yyparse();
}

int yyerror()
{
	printf("Error \n");
	exit(0);
}
%{ 
#include "y.tab.h" 
%} 

%% 

a {return A;} 
b {return B;} 
[\n] {return '\n';}

%% 
 
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta http-equiv="refresh" content="1">
</head>
<body>
<h1>Display Current Date & Time</h1>
<h2>
<?php
echo "The time from the server is <span style='color:red';> " . date("h:i:sa")."</span>";
echo '<br />';
echo "Today's Date is <span style='color:red';>" . date("d-m-Y");
date_default_timezone_set('Asia/Kolkata');
echo " </span> and Current Time is <span style='color:red';>" . date("h:i:s a")."</span>";
?>
</h2>
</body>
</html>
import numpy as np
import pandas as pd
data = pd.DataFrame(data=pd.read_csv('2.csv'))
concepts = np.array(data.iloc[:,0:-1])
target = np.array(data.iloc[:,-1])

# Nothing Commit

def learn(concepts, target):
    specific_h = concepts[0].copy()
    general_h = [["?" for i in range(len(specific_h))] for i in range(len(specific_h))]
    for i, h in enumerate(concepts):
        if target[i] == "Yes":
            for x in range(len(specific_h)):
                if h[x] != specific_h[x]:
                    specific_h[x] = '?'
                    general_h[x][x] = '?'
        if target[i] == "No":
            for x in range(len(specific_h)):
                if h[x] != specific_h[x]:
                    general_h[x][x] = specific_h[x]
                else:
                    general_h[x][x] = '?'

    indices = [i for i, val in enumerate(general_h) if val == ['?', '?', '?', '?', '?', '?']]
    for i in indices:
        general_h.remove(['?', '?', '?', '?', '?', '?'])
    return specific_h, general_h

s_final, g_final = learn(concepts, target)
print("Final S:", s_final, sep="\n")
print("Final G:", g_final, sep="\n")






<html>
<head>
<style>

table, td, th
{
border: 1px solid black;
width: 35%;
text-align: center;
background-color: DarkGray;
}
table { margin: auto; }
input { text-align:right; }
</style>
<script type="text/javascript">
function add()
{
var val1 = parseFloat(document.getElementById("value1").value);
var val2 = parseFloat(document.getElementById("value2").value);
if(isNaN(val1)||isNaN(val2))
{

alert("ENTER VALID NUMBER");

}
else
{

document.getElementById("answer").value=val1+val2;

}
}
function sub()

{
var val1 = parseFloat(document.getElementById("value1").value);
var val2 = parseFloat(document.getElementById("value2").value);
if(isNaN(val1)||isNaN(val2))
{

alert("ENTER VALID NUMBER");

}
else
{

document.getElementById("answer").value=val1-val2;

}
}

function mul()

{
var val1 = parseFloat(document.getElementById("value1").value);
var val2 = parseFloat(document.getElementById("value2").value);
if(isNaN(val1)||isNaN(val2))
{

alert("ENTER VALID NUMBER");

}
else
{

document.getElementById("answer").value=val1*val2;

}
}
function div()

{
var val1 = parseFloat(document.getElementById("value1").value);
var val2 = parseFloat(document.getElementById("value2").value);
if(isNaN(val1)||isNaN(val2))
{

alert("ENTER VALID NUMBER");

}
else
{

document.getElementById("answer").value=val1/val2;

}
}

function cls()

{
value1.value="";
value2.value="";
answer.value="";

}
</script>
</head>
<body>
<table>

<tr><thcolspan="4"> SIMPLE CALCULATOR </th></tr>
<tr><td>value1</td><td><input type="text" id="value1" name="value1" value=""/></td>
<td>value2</td><td><input type="text" id="value2" name="value2" value=""/></td></tr>
<tr><td><input type="button" name="Addition" value="Addition"
onclick="javascript:add()"/></td>
<td><input type="button" name="Subtraction" value="Subtraction"
onclick="javascript:sub()"/></td>
<td><input type="button" name="Multiplication" value="Multiplication"
onclick="javascript:mul()"/></td>
<td><input type="button" name="Division" value="Division"
onclick="javascript:div()"/></td></tr></td>
<tr><td>Answer:</td><td><input type="text" id="answer" name="answer" value=""
disabled/></td>
<td colspan="2"><input type="button" name="clear" value="CLEAR ALL"
onclick="javascript:cls()"/></td>
</tr>
</table>
</body>
</html>/* Perspective viewing of a colored cube */
#include <GL/glut.h>
#include <stdlib.h>

GLfloat vertices[][3] = { { -1.0, -1.0, -1.0 }, { 1.0, -1.0, -1.0 },
	{ 1.0, 1.0, -1.0 }, { -1.0, 1.0, -1.0 }, { -1.0, -1.0, 1.0 },
	{ 1.0, -1.0, 1.0 }, { 1.0, 1.0, 1.0 }, { -1.0, 1.0, 1.0 } };

GLfloat normals[][3] = { { -1.0, -1.0, -1.0 }, { 1.0, -1.0, -1.0 },
	{ 1.0, 1.0, -1.0 }, { -1.0, 1.0, -1.0 }, { -1.0, -1.0, 1.0 },
	{ 1.0, -1.0, 1.0 }, { 1.0, 1.0, 1.0 }, { -1.0, 1.0, 1.0 } };

GLfloat colors[][3] = { { 0.0, 0.0, 0.0 }, { 1.0, 0.0, 0.0 },
	{ 1.0, 1.0, 0.0 }, { 0.0, 1.0, 0.0 }, { 0.0, 0.0, 1.0 },
	{ 1.0, 0.0, 1.0 }, { 1.0, 1.0, 1.0 }, { 0.0, 1.0, 1.0 } };

void polygon(int a, int b, int c, int d)
{
	glBegin(GL_POLYGON);
	glColor3fv(colors[a]);
	glNormal3fv(normals[a]);
	glVertex3fv(vertices[a]);
	glColor3fv(colors[b]);
	glNormal3fv(normals[b]);
	glVertex3fv(vertices[b]);
	glColor3fv(colors[c]);
	glNormal3fv(normals[c]);
	glVertex3fv(vertices[c]);
	glColor3fv(colors[d]);
	glNormal3fv(normals[d]);
	glVertex3fv(vertices[d]);
	glEnd();
}

void colorcube()
{
	polygon(0, 3, 2, 1);
	polygon(2, 3, 7, 6);
	polygon(0, 4, 7, 3);
	polygon(1, 2, 6, 5);
	polygon(4, 5, 6, 7);
	polygon(0, 1, 5, 4);
}

static GLfloat theta[] = { 0.0, 0.0, 0.0 };
static GLint axis = 2;
static GLdouble viewer[] = { 0.0, 0.0, 5.0 };

void display(void)
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glLoadIdentity();
	gluLookAt(viewer[0], viewer[1], viewer[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
	glRotatef(theta[0], 1.0, 0.0, 0.0);
	glRotatef(theta[1], 0.0, 1.0, 0.0);
	glRotatef(theta[2], 0.0, 0.0, 1.0);

	colorcube();

	glFlush();
	glutSwapBuffers();
}

void mouse(int btn, int state, int x, int y)
{
	if (btn == GLUT_LEFT_BUTTON && state == GLUT_DOWN)
		axis = 0;
	if (btn == GLUT_MIDDLE_BUTTON && state == GLUT_DOWN)
		axis = 1;
	if (btn == GLUT_RIGHT_BUTTON && state == GLUT_DOWN)
		axis = 2;
	theta[axis] += 2.0;
	if (theta[axis] > 360.0)
		theta[axis] -= 360.0;
	display();
}

void keys(unsigned char key, int x, int y)
{
	if (key == 'x')
		viewer[0] -= 1.0;
	if (key == 'X')
		viewer[0] += 1.0;
	if (key == 'y')
		viewer[1] -= 1.0;
	if (key == 'Y')
		viewer[1] += 1.0;
	if (key == 'z')
		viewer[2] -= 1.0;
	if (key == 'Z')
		viewer[2] += 1.0;
	display();
}

void myReshape(int w, int h)
{
	glViewport(0, 0, w, h);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (w <= h)
		glFrustum(-2.0, 2.0, -2.0 * (GLfloat)h / (GLfloat)w, 2.0 * (GLfloat)h / (GLfloat)w, 2.0, 20.0);
	else
		glFrustum(-2.0, 2.0, -2.0 * (GLfloat)w / (GLfloat)h, 2.0 * (GLfloat)w / (GLfloat)h, 2.0, 20.0);
	glMatrixMode(GL_MODELVIEW);
}

int main(int argc, char** argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
	glutInitWindowSize(500, 500);
	glutCreateWindow("Colorcube Viewer");
	glutReshapeFunc(myReshape);
	glutDisplayFunc(display);
	glutMouseFunc(mouse);
	glutKeyboardFunc(keys);
	glEnable(GL_DEPTH_TEST);
	glutMainLoop();
	return 0;
}
<?php
$file = 'count.txt';
$count = strval(file_get_contents($file));
file_put_contents($file, $count + 1);
echo("You are visitor number:".$count);
?>/* Bresenhams Line Drawing Algorithm */
#include <GL/glut.h>
#include <math.h>
#include <stdio.h>
int x00, y00, xEnd, yEnd;

void display()
{
	int i, j;
	glClear(GL_COLOR_BUFFER_BIT);
	line(x00, y00, xEnd, yEnd);
}

void drawPixel(int x, int y)
{
	glPointSize(3.0);
	glBegin(GL_POINTS);
	glVertex2i(x, y);
	glEnd();
	glFlush();
}

void line(int x00, int y00, int xEnd, int yEnd)
{
	int dx = fabs(xEnd - x00), dy = fabs(yEnd - y00);
	int p = 2 * dy - dx;
	int twoDy = 2 * dy - dx, twoDyMinusDx = 2 * (dy - dx);
	int x, y;

	/*Determine which endpoint to use as starting position*/

	if (x00 > xEnd) {
		x = xEnd;
		y = yEnd;
		xEnd = x00;
	} else {
		x = x00;
		y = y00;
	}

	drawPixel(x, y);

	while (x < xEnd) {
		x++;
		if (p < 0)
			p += twoDy;
		else {
			y++;
			p += twoDyMinusDx;
		}

		drawPixel(x, y);
	}
}

void myinit()
{
	glClearColor(0.4, 0.4, 0.4, 1.0);
	glPointSize(2.0);
	glColor3f(0.5,1,0.5);
	/* glMatrixMode(GL_PROJECTION); */
	/* glLoadIdentity(); */
	gluOrtho2D(0.0, 950.0, 0.0, 950.0);
}

void main(int argc, char** argv)
{
	glutInit(&argc, argv);

	printf("Enter two end points of the line");
	scanf("%d %d %d %d", &x00, &y00, &xEnd, &yEnd);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowSize(500, 500);
	glutInitWindowPosition(10, 10);
	glutCreateWindow("BRESENHAM'S LINE DRAWING ALGORITHM");
	glutDisplayFunc(display);
	myinit();
	glutMainLoop();
}

#include <stdio.h>
#include <stdlib.h>

int arrival[10];
int burst[10];
int rem[10];
int wait[10];
int finish[10];
int turnaround[10];
int flag[10];
void roundrobin(int, int, int[], int[]);
void srtf(int);

int main()
{
	int n, tq, choice;
	int bt[10], st[10], i, j;
	for (;;) {

		printf("enter the choice\n1. round robin\n 2.srt 3.Exit\n");
		scanf("%d", &choice);

		switch (choice) {

			case 1:
				printf("enter no. of process:\n");
				scanf("%d", &n);
				printf("enter brust time\n");
				for (i = 0; i < n; i++) {
					scanf("%d", &bt[i]);
					st[i] = bt[i];
				}
				printf("enter time quantum");
				scanf("%d", &tq);
				roundrobin(n, tq, st, bt);
				break;

			case 2:
				printf("enter no. of process:\n");
				scanf("%d", &n);
				srtf(n);
				break;

			case 3:
				return 0;
		}
	}
}

void roundrobin(int n, int tq, int st[], int bt[])
{
	int time = 0;
	int tat[10], wt[10], i, count = 0, swt = 0, stat = 0, temp1, sq = 0;

	while (1) {
		for (i = 0, count = 0; i < n; i++) {
			temp1 = tq;
			if (st[i] == 0) {
				count++;
				continue;
			}
			if (st[i] > tq)
				st[i] = st[i] - tq;
			else if (st[i] >= 0) {
				temp1 = st[i];
				st[i] = 0;
			}
			sq = sq + temp1;
			tat[i] = sq;
		}
		if (n == count)
			break;
	}
	for (i = 0; i < n; i++) {
		wt[i] = tat[i] - bt[i];
		swt = swt + wt[i];
		stat = stat + tat[i];
	}
	printf("process_no burst time wait time turnaround time\n");
	for (i = 0; i < n; i++)
		printf("%d\t\t%d\t\t%d\t\t%d\n", i + 1, bt[i], wt[i], tat[i]);
	printf("average waiting time is %f\n average turnaround time is %f\n", (float)swt / n, (float)stat / n);
}

void srtf(int n)
{
	int stat = 0, swt = 0, time = 0, count = 0, i, j, min = 999;
	for (i = 1; i <= n; i++) {
		printf("arrival of p%d:", i);
		scanf("%d", &arrival[i]);
		printf("burst of p%d:", i);
		scanf("%d", &burst[i]);
		rem[i] = burst[i];
		flag[i] = 0;
	}

	while (1) {
		for (i = 1, min = 999; i <= n; i++)
			if (arrival[i] <= time && flag[i] == 0)
				if (rem[i] < min) {
					min = rem[i];
					j = i;
				}
		time++;
		rem[j] -= 1;
		if (rem[j] == 0) {
			finish[j] = time;
			flag[j] = 1;
			count++;
		}
		if (count == n)
			break;
	}
	for (i = 1; i <= n; i++) {
		turnaround[i] = finish[i] - arrival[i];
		wait[i] = turnaround[i] - burst[i];
		stat += turnaround[i];
		swt += wait[i];
	}

	printf("the process table:\n\t process no.\t|finish\t|wait\t|turnaround\t\n");
	for (i = 1; i <= n; i++)
		printf("\t%d  \t%d  \t%d  \t%d  \t%d \t%d\n", i, arrival[i], burst[i], finish[i], wait[i], turnaround[i]);
	printf("averagewaittime: %f\t avgturnaroundtime: %f\n", (float)swt / n, (float)stat / n);
	return;
}
# Backprop on the Seeds Dataset
from random import seed
from random import randrange
from random import random
from csv import reader
from math import exp

# Load a CSV file
def load_csv(filename):
	dataset = list()
	with open(filename, 'r') as file:
		csv_reader = reader(file)
		for row in csv_reader:
			if not row:
				continue
			dataset.append(row)
	return dataset

# Convert string column to float
def str_column_to_float(dataset, column):
	for row in dataset:
		row[column] = float(row[column].strip())

# Convert string column to integer
def str_column_to_int(dataset, column):
	class_values = [row[column] for row in dataset]
	unique = set(class_values)
	lookup = dict()
	for i, value in enumerate(unique):
		lookup[value] = i
	for row in dataset:
		row[column] = lookup[row[column]]
	return lookup

# Find the min and max values for each column
def dataset_minmax(dataset):
	minmax = list()
	stats = [[min(column), max(column)] for column in zip(*dataset)]
	return stats

# Rescale dataset columns to the range 0-1
def normalize_dataset(dataset, minmax):
	for row in dataset:
		for i in range(len(row)-1):
			row[i] = (row[i] - minmax[i][0]) / (minmax[i][1] - minmax[i][0])

# Split a dataset into k folds
def cross_validation_split(dataset, n_folds):
	dataset_split = list()
	dataset_copy = list(dataset)
	fold_size = int(len(dataset) / n_folds)
	for i in range(n_folds):
		fold = list()
		while len(fold) < fold_size:
			index = randrange(len(dataset_copy))
			fold.append(dataset_copy.pop(index))
		dataset_split.append(fold)
	return dataset_split

# Calculate accuracy percentage
def accuracy_metric(actual, predicted):
	correct = 0
	for i in range(len(actual)):
		if actual[i] == predicted[i]:
			correct += 1
	return correct / float(len(actual)) * 100.0

# Evaluate an algorithm using a cross validation split
def evaluate_algorithm(dataset, algorithm, n_folds, *args):
	folds = cross_validation_split(dataset, n_folds)
	scores = list()
	for fold in folds:
		train_set = list(folds)
		train_set.remove(fold)
		train_set = sum(train_set, [])
		test_set = list()
		for row in fold:
			row_copy = list(row)
			test_set.append(row_copy)
			row_copy[-1] = None
		predicted = algorithm(train_set, test_set, *args)
		actual = [row[-1] for row in fold]
		accuracy = accuracy_metric(actual, predicted)
		scores.append(accuracy)
	return scores

# Calculate neuron activation for an input
def activate(weights, inputs):
	activation = weights[-1]
	for i in range(len(weights)-1):
		activation += weights[i] * inputs[i]
	return activation

# Transfer neuron activation
def transfer(activation):
	return 1.0 / (1.0 + exp(-activation))

# Forward propagate input to a network output
def forward_propagate(network, row):
	inputs = row
	for layer in network:
		new_inputs = []
		for neuron in layer:
			activation = activate(neuron['weights'], inputs)
			neuron['output'] = transfer(activation)
			new_inputs.append(neuron['output'])
		inputs = new_inputs
	return inputs

# Calculate the derivative of an neuron output
def transfer_derivative(output):
	return output * (1.0 - output)

# Backpropagate error and store in neurons
def backward_propagate_error(network, expected):
	for i in reversed(range(len(network))):
		layer = network[i]
		errors = list()
		if i != len(network)-1:
			for j in range(len(layer)):
				error = 0.0
				for neuron in network[i + 1]:
					error += (neuron['weights'][j] * neuron['delta'])
				errors.append(error)
		else:
			for j in range(len(layer)):
				neuron = layer[j]
				errors.append(expected[j] - neuron['output'])
		for j in range(len(layer)):
			neuron = layer[j]
			neuron['delta'] = errors[j] * transfer_derivative(neuron['output'])

# Update network weights with error
def update_weights(network, row, l_rate):
	for i in range(len(network)):
		inputs = row[:-1]
		if i != 0:
			inputs = [neuron['output'] for neuron in network[i - 1]]
		for neuron in network[i]:
			for j in range(len(inputs)):
				neuron['weights'][j] += l_rate * neuron['delta'] * inputs[j]
			neuron['weights'][-1] += l_rate * neuron['delta']

# Train a network for a fixed number of epochs
def train_network(network, train, l_rate, n_epoch, n_outputs):
	for epoch in range(n_epoch):
		for row in train:
			outputs = forward_propagate(network, row)
			expected = [0 for i in range(n_outputs)]
			expected[row[-1]] = 1
			backward_propagate_error(network, expected)
			update_weights(network, row, l_rate)

# Initialize a network
def initialize_network(n_inputs, n_hidden, n_outputs):
	network = list()
	hidden_layer = [{'weights':[random() for i in range(n_inputs + 1)]} for i in range(n_hidden)]
	network.append(hidden_layer)
	output_layer = [{'weights':[random() for i in range(n_hidden + 1)]} for i in range(n_outputs)]
	network.append(output_layer)
	return network

# Make a prediction with a network
def predict(network, row):
	outputs = forward_propagate(network, row)
	return outputs.index(max(outputs))

# Backpropagation Algorithm With Stochastic Gradient Descent
def back_propagation(train, test, l_rate, n_epoch, n_hidden):
	n_inputs = len(train[0]) - 1
	n_outputs = len(set([row[-1] for row in train]))
	network = initialize_network(n_inputs, n_hidden, n_outputs)
	train_network(network, train, l_rate, n_epoch, n_outputs)
	predictions = list()
	for row in test:
		prediction = predict(network, row)
		predictions.append(prediction)
	return(predictions)

# Test Backprop on Seeds dataset
seed(1)
# load and prepare data
filename = 'data.csv'
dataset = load_csv(filename)
for i in range(len(dataset[0])-1):
	str_column_to_float(dataset, i)
# convert class column to integers
str_column_to_int(dataset, len(dataset[0])-1)
# normalize input variables
minmax = dataset_minmax(dataset)
normalize_dataset(dataset, minmax)
# evaluate algorithm
n_folds = 2
l_rate = 0.3
n_epoch = 500
n_hidden = 5
scores = evaluate_algorithm(dataset, back_propagation, n_folds, l_rate, n_epoch, n_hidden)
print('Scores: %s' % scores)
print('Mean Accuracy: %.3f%%' % (sum(scores)/float(len(scores))))# # Find-S Algorithm:
# ## Algorithm:
# 1. Initialize h to the most specific hypothesis in H
# 2. For each positive training instance x
#         i. For each attribute constraint a i in h :
#             a. If the constraint a i in h is satisfied by x Then do nothing
#             b. Else replace a i in h by the next more general constraint that is satisfied by x
# 3. Output hypothesis h
# 

# In[1]:


import csv


# ### Read File:
# Load the csv file and asign each row to a data frame
# Also print the row to see the dataset (optional)


a=[]
with open('1.csv') as csfile:
    reader = csv.reader(csfile)
    for row in reader:
        a.append(row)
        print(row)
num_attributes=len(a[0])-1


# 1. The most general hypothesis is represented by:
#     ```['?', '?', '?', '?', '?', '?']```
# 2. The most specific hypothesis is represented by:
#     ```['0', '0', '0', '0', '0', '0']```

# In[ ]:


print("The most general hypothesis:",["?"]*num_attributes)
print("The most specific hypothesis:",["0"]*num_attributes)


# ### Algorithm Implementation:
# Implementation of the above algorithm by updaing the hypothesis at each iteration and output the final hypothesis.

# In[ ]:


hypothesis=a[0][:-1]
print("\n Find S: Finding a maximally specific hypothesis")
for i in range (len(a)):
    if a[i][num_attributes] == "Yes":
        for j in range(num_attributes):
            if a[i][j]!=hypothesis[j]:
                hypothesis[j]='?'
    print("The taining example no:",i+1," the hyposthesis is:",hypothesis)
print("\n The maximally specific hypohthesis for training set is")
print(hypothesis)

import csv
import math


def majorClass(attributes,data,target):
    freq={}
    index=attributes.index(target)
    for tuple in data:
        if tuple[index] in freq:
            freq[tuple[index]]+=1
        else:
            freq[tuple[index]]=1
    max=0
    major=""	
    for key in freq.keys():
        if freq[key]>max:
            max=freq[key]
            major=key
		
    return major
	
def entropy(attributes,data,targetAttr):
    freq={}
    dataEntropy=0.0
    i=0
    for entry in attributes:
        if(targetAttr==entry):
            break
        i=i+1
    i=i-1
    for entry in data:
        if entry[i] in freq:
            freq[entry[i]]+=1.0
        else:
            freq[entry[i]]=1.0
    for freq in freq.values():
        dataEntropy+=(-freq/len(data))*math.log(freq/len(data),2)
    return dataEntropy
	

def info_gain(attributes,data,attr,targetAttr):
    freq={}
    subsetEntropy=0.0
    i=attributes.index(attr)
    for entry in data:
        if entry[i] in freq:
            freq[entry[i]]+=1.0
        else:
            freq[entry[i]]=1.0
    for val in freq.keys():
        valProb=freq[val]/sum(freq.values())
        dataSubset=[entry for entry in data if entry[i]==val]
        subsetEntropy+=valProb*entropy(attributes,dataSubset,targetAttr)
    return (entropy(attributes,data,targetAttr)-subsetEntropy)
	 
def attr_choose(data,attributes,target):
    best=attributes[0]
    maxGain=0;
    for attr in attributes:
        newGain=info_gain(attributes,data,attr,target)
        if newGain>maxGain:
            maxGain=newGain
            best=attr
    return best
	
def get_values(data,attributes,attr):
    index=attributes.index(attr)
    values=[]
    for entry in data:
        if entry[index] not in values:
            values.append(entry[index])
    return values
	
def get_data(data,attributes,best,val):
	new_data=[[]]
	index=attributes.index(best)
	for entry in data:
		if(entry[index]==val):
			newEntry=[]
			for i in range(0,len(entry)):
				if(i!=index):
					newEntry.append(entry[i])
			new_data.append(newEntry)
	new_data.remove([])
	return new_data
	
def build_tree(data,attributes,target):
	data=data[:]
	vals=[record[attributes.index(target)] for record in data]
	default=majorClass(attributes,data,target)
	if not data or (len(attributes)-1)<=0:
		return default
	elif vals.count(vals[0])==len(vals):
		return vals[0]
	else:
		best=attr_choose(data,attributes,target)
		tree={best:{}}
		for val in get_values(data,attributes,best):
			new_data=get_data(data,attributes,best,val)
			newAttr=attributes[:]
			newAttr.remove(best)
			subtree=build_tree(new_data,newAttr,target)
			tree[best][val]=subtree
	return tree
	
def execute_decision_tree():
    data=[]
    with open("3.csv") as tsv:
        for line in csv.reader(tsv):
            data.append(tuple(line))
        print("Number of records:",len(data))
		
    attributes=['outlook','temperature','humidity','wind','play']
    target=attributes[-1]
	
    acc=[]
    training_set=[x for i,x in enumerate(data)]
    tree=build_tree(training_set,attributes,target)
    print(tree)
	
    results=[]
    test_set=[('rainy','mild','high','strong')]
    for entry in test_set:
        tempDict=tree.copy()
        result=""
        while(isinstance(tempDict,dict)):
            child=[]
            nodeVal=next(iter(tempDict))
            child=tempDict[next(iter(tempDict))].keys()
            tempDict=tempDict[next(iter(tempDict))]
            index=attributes.index(nodeVal)
            value=entry[index]
            if (value in tempDict.keys()):
                result=tempDict[value]
                tempDict=tempDict[value]
            else:
                result="Null"
                break
        if result!="Null":
            results.append(result==entry[-1])
        print(result)
        
if __name__=="__main__":
    execute_decision_tree()
			

